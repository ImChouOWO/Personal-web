/*
 * @svg-drawing/img-trace v5.0.1-beta.0 
 * 
 * Copyright (C) Kazuto Kamei.
 * This source code is licensed under the MIT license.
 */
import{Svg as t,Move as n,Point as o,Close as i,Line as e,QuadraticCurve as s,Path as a}from"@svg-drawing/core";function r(t,n,o){return n in t?Object.defineProperty(t,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[n]=o,t}const h=t=>{const n=t.width*t.height;if(!(t.data.length<4*n))return t;const o=new Uint8ClampedArray(4*n);for(let i=0;i<n;i++)o[4*i]=t.data[3*i],o[4*i+1]=t.data[3*i+1],o[4*i+2]=t.data[3*i+2],o[4*i+3]=255;return{...t,data:o}},l=[[.27901,.44198,.27901],[.135336,.228569,.272192,.228569,.135336],[.086776,.136394,.178908,.195843,.178908,.136394,.086776],[.063327,.093095,.122589,.144599,.152781,.144599,.122589,.093095,.063327],[.049692,.069304,.089767,.107988,.120651,.125194,.120651,.107988,.089767,.069304,.049692]];class d{constructor(t){let{radius:n,delta:o}=t;r(this,"radius",void 0),r(this,"delta",void 0),this.radius=n??0,this.delta=o??20}apply(t){const n=h(t),o=new Uint8ClampedArray(n.data);let i=Math.floor(this.radius);if(i<1)return n;i>l.length&&(i=l.length);let e=Math.abs(this.delta);e>1024&&(e=1024);const s=l[i-1];for(let t=0;t<n.height;t++)for(let e=0;e<n.width;e++){let a=0,r=0,h=0,l=0,d=0;for(let o=-i;o<i+1;o++)if(e+o>0&&e+o<n.width){const p=4*(t*n.width+e+o);a+=n.data[p]*s[o+i],r+=n.data[p+1]*s[o+i],h+=n.data[p+2]*s[o+i],l+=n.data[p+3]*s[o+i],d+=s[o+i]}const p=4*(t*n.width+e);o[p]=Math.floor(a/d),o[p+1]=Math.floor(r/d),o[p+2]=Math.floor(h/d),o[p+3]=Math.floor(l/d)}const a=new Uint8ClampedArray(o);for(let t=0;t<n.height;t++)for(let e=0;e<n.width;e++){let r=0,h=0,l=0,d=0,p=0;for(let o=-i;o<i+1;o++)if(t+o>0&&t+o<n.height){const c=4*((t+o)*n.width+e);r+=a[c]*s[o+i],h+=a[c+1]*s[o+i],l+=a[c+2]*s[o+i],d+=a[c+3]*s[o+i],p+=s[o+i]}const c=4*(t*n.width+e);o[c]=Math.floor(r/p),o[c+1]=Math.floor(h/p),o[c+2]=Math.floor(l/p),o[c+3]=Math.floor(d/p)}for(let t=0;t<n.height;t++)for(let i=0;i<n.width;i++){const s=4*(t*n.width+i);Math.abs(o[s]-n.data[s])+Math.abs(o[s+1]-n.data[s+1])+Math.abs(o[s+2]-n.data[s+2])+Math.abs(o[s+3]-n.data[s+3])>e&&(o[s]=n.data[s],o[s+1]=n.data[s+1],o[s+2]=n.data[s+2],o[s+3]=n.data[s+3])}return new ImageData(o,n.width,n.height)}}class p{constructor(t){r(this,"corsenabled",void 0),this.corsenabled=t.corsenabled??!0}fromUrl(t,n){const o=(n,o)=>{const i=new Image;this.corsenabled&&(i.crossOrigin="Anonymous"),i.onload=()=>{this.fromImageElement(i,n)},i.onerror=t=>{o?o(t):console.error(t)},i.src=t};if(!n)return new Promise(o);o(n)}fromImageElement(t,n){const o=(n,o)=>{const i=document.createElement("canvas");i.width=t.naturalWidth||t.width,i.height=t.naturalHeight||t.height;const e=i.getContext("2d");null==e||e.drawImage(t,0,0);const s=null==e?void 0:e.getImageData(0,0,i.width,i.height);if(!s){if(o)return void o("error canvas context.");throw"error canvas context."}n(s)};if(!n)return new Promise(o);o(n)}}class c{static imageData(t,n){let{numberOfColors:o,colorQuantCycles:i}=void 0===n?{}:n;const e=o||16,s=i||3,a=h(t),r=this._deterministic(a,e);let l=[];for(let t=0;t<s;t++){if(t>0)for(let t=0;t<r.length;t++)l[t].n>0&&(r[t]={r:Math.floor(l[t].r/l[t].n),g:Math.floor(l[t].g/l[t].n),b:Math.floor(l[t].b/l[t].n),a:Math.floor(l[t].a/l[t].n)});l=Array.from({length:r.length},(()=>({r:0,g:0,b:0,a:0,n:0})));for(let t=0;t<a.height;t++)for(let n=0;n<a.width;n++){const o=4*(t*a.width+n);let i=1024;const e=r.reduce(((t,n,e)=>{const s=Math.abs(n.r-a.data[o])+Math.abs(n.g-a.data[o+1])+Math.abs(n.b-a.data[o+2])+Math.abs(n.a-a.data[o+3]);return s<i?(i=s,e):t}),0);l[e].r+=a.data[o],l[e].g+=a.data[o+1],l[e].b+=a.data[o+2],l[e].a+=a.data[o+3],l[e].n+=1}}return r}static _deterministic(t,n){const o=[],i=Math.ceil(Math.sqrt(n)),e=Math.ceil(n/i),s=t.width/(i+1),a=t.height/(e+1);for(let r=0;r<e;r++)for(let e=0;e<i&&o.length!==n;e++){const n=4*Math.floor((r+1)*a*t.width+(e+1)*s);o.push({r:t.data[n],g:t.data[n+1],b:t.data[n+2],a:t.data[n+3]})}return o}static number(t){if(void 0===t&&(t=16),t<8)return this.grey(t);const n=[],o=Math.floor(Math.pow(t,1/3)),i=Math.floor(255/(o-1));for(let t=0;t<o;t+=1)for(let e=0;e<o;e+=1)for(let s=0;s<o;s+=1)n.push({r:t*i,g:e*i,b:s*i,a:255});const e=t-o*o*o;for(let t=0;t<e;t++)n.push({r:Math.floor(255*Math.random()),g:Math.floor(255*Math.random()),b:Math.floor(255*Math.random()),a:Math.floor(255*Math.random())});return n}static grey(t){void 0===t&&(t=16);const n=[],o=Math.floor(255/(t-1));for(let i=0;i<t;i++)n.push({r:i*o,g:i*o,b:i*o,a:255});return n}}const g=0,f=1,u=2,b=3,m=4,x=5,y=6,w=7,M=8,_=-1,v=[[[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1]],[[0,1,0,-1],[-1,-1,-1,-1],[-1,-1,-1,-1],[0,2,-1,0]],[[-1,-1,-1,-1],[-1,-1,-1,-1],[0,1,0,-1],[0,0,1,0]],[[0,0,1,0],[-1,-1,-1,-1],[0,2,-1,0],[-1,-1,-1,-1]],[[-1,-1,-1,-1],[0,0,1,0],[0,3,0,1],[-1,-1,-1,-1]],[[13,3,0,1],[13,2,-1,0],[7,1,0,-1],[7,0,1,0]],[[-1,-1,-1,-1],[0,1,0,-1],[-1,-1,-1,-1],[0,3,0,1]],[[0,3,0,1],[0,2,-1,0],[-1,-1,-1,-1],[-1,-1,-1,-1]],[[0,3,0,1],[0,2,-1,0],[-1,-1,-1,-1],[-1,-1,-1,-1]],[[-1,-1,-1,-1],[0,1,0,-1],[-1,-1,-1,-1],[0,3,0,1]],[[11,1,0,-1],[14,0,1,0],[14,3,0,1],[11,2,-1,0]],[[-1,-1,-1,-1],[0,0,1,0],[0,3,0,1],[-1,-1,-1,-1]],[[0,0,1,0],[-1,-1,-1,-1],[0,2,-1,0],[-1,-1,-1,-1]],[[-1,-1,-1,-1],[-1,-1,-1,-1],[0,1,0,-1],[0,0,1,0]],[[0,1,0,-1],[-1,-1,-1,-1],[-1,-1,-1,-1],[0,2,-1,0]],[[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1]]],q=[{r:0,g:0,b:0,a:255},{r:50,g:50,b:50,a:255},{r:100,g:100,b:100,a:255},{r:150,g:150,b:150,a:255},{r:200,g:200,b:200,a:255}];class A{constructor(t){void 0===t&&(t={}),r(this,"ltres",void 0),r(this,"qtres",void 0),r(this,"rightangleenhance",void 0),r(this,"pathOmit",void 0),r(this,"commandOmit",void 0),r(this,"pathAttrs",void 0),r(this,"palettes",void 0),this.ltres=t.ltres??1,this.qtres=t.qtres??1,this.rightangleenhance=t.rightangleenhance??!0,this.pathOmit=t.pathOmit??8,this.commandOmit=t.commandOmit??0,this.pathAttrs={strokeWidth:"1",...t.pathAttrs||{}},this.palettes=t.palettes||q}load(n){const o=h(n),i=this._colorQuantization(o),e=[];for(let t=0;t<this.palettes.length;t++){const n=this._edgeDetection(i,t),o=this._pathScan(n),s=this._interpolation(o).map(this._tracePath.bind(this));e.push(s)}const s=this._createPaths(e);return new t({width:i[0].length-2,height:i.length-2}).addPath(s)}_colorQuantization(t){return Array.from({length:t.height+2},((n,o)=>Array.from({length:t.width+2},((n,i)=>{if(0===i||i===t.width+1||0===o||o===t.height+1)return-1;const e=i-1,s=4*((o-1)*t.width+e);return this._findPaletteIndex({r:t.data[s],g:t.data[s+1],b:t.data[s+2],a:t.data[s+3]})}))))}_findPaletteIndex(t){let{r:n,g:o,b:i,a:e}=t,s=1024;return this.palettes.reduce(((t,a,r)=>{const h=Math.abs(a.r-n)+Math.abs(a.g-o)+Math.abs(a.b-i)+Math.abs(a.a-e);return h<s?(s=h,r):t}),0)}_edgeDetection(t,n){const o=[],i=t.length,e=t[0].length;for(let s=0;s<i;s++){o[s]=[];for(let i=0;i<e;i++)o[s][i]=0===s||0===i?0:(t[s-1][i-1]===n?1:0)+(t[s-1][i]===n?2:0)+(t[s][i-1]===n?8:0)+(t[s][i]===n?4:0)}return o}_pointpoly(t,n){let o=!1;for(let i=0,e=n.length-1;i<n.length;e=i++)o=n[i].y>t.y!=n[e].y>t.y&&t.x<(n[e].x-n[i].x)*(t.y-n[i].y)/(n[e].y-n[i].y)+n[i].x?!o:o;return o}_pathScan(t){const n=t[0].length,o=t.length,i=[];let e=0;for(let s=0;s<o;s++)for(let a=0;a<n;a++){const r=t[s][a];if(4!==r&&11!==r)continue;let h=a,l=s,d=1,p=0,c=!1;for(i[e]={points:[],boundingbox:[h,l,h,l],holechildren:[],isholepath:!1};!c;){i[e].points[p]={x:h-1,y:l-1,direction:_},h-1<i[e].boundingbox[0]&&(i[e].boundingbox[0]=h-1),h-1>i[e].boundingbox[2]&&(i[e].boundingbox[2]=h-1),l-1<i[e].boundingbox[1]&&(i[e].boundingbox[1]=l-1),l-1>i[e].boundingbox[3]&&(i[e].boundingbox[3]=l-1);const s=v[t[l][h]][d];if(t[l][h]=s[0],d=s[1],h+=s[2],l+=s[3],h-1===i[e].points[0].x&&l-1===i[e].points[0].y)if(c=!0,i[e].points.length<this.pathOmit)i.pop();else{if(11===r){i[e].isholepath=!0;let t=0,s=[-1,-1,n+1,o+1];for(let n=0;n<e;n++)!i[n].isholepath&&this._boundingboxincludes(i[n].boundingbox,i[e].boundingbox)&&this._boundingboxincludes(s,i[n].boundingbox)&&this._pointpoly(i[e].points[0],i[n].points)&&(t=n,s=i[n].boundingbox);i[t].holechildren.push(e)}e++}p++}}return i}_boundingboxincludes(t,n){return t[0]<n[0]&&t[1]<n[1]&&t[2]>n[2]&&t[3]>n[3]}_interpolation(t){const n=[];let o=0,i=0,e=0,s=0;for(let a=0;a<t.length;a++){n[a]={points:[],boundingbox:t[a].boundingbox,holechildren:t[a].holechildren,isholepath:t[a].isholepath};const r=t[a].points.length;for(let h=0;h<r;h++)o=(h+1)%r,i=(h+2)%r,e=(h-1+r)%r,s=(h-2+r)%r,this.rightangleenhance&&this._testrightangle(t[a],s,e,h,o,i)&&(n[a].points.length>0&&(n[a].points[n[a].points.length-1].direction=this._getdirection(n[a].points[n[a].points.length-1].x,n[a].points[n[a].points.length-1].y,t[a].points[h].x,t[a].points[h].y)),n[a].points.push({x:t[a].points[h].x,y:t[a].points[h].y,direction:this._getdirection(t[a].points[h].x,t[a].points[h].y,(t[a].points[h].x+t[a].points[o].x)/2,(t[a].points[h].y+t[a].points[o].y)/2)})),n[a].points.push({x:(t[a].points[h].x+t[a].points[o].x)/2,y:(t[a].points[h].y+t[a].points[o].y)/2,direction:this._getdirection(t[a].points[h].x+t[a].points[o].x,t[a].points[h].y+t[a].points[o].y,t[a].points[o].x+t[a].points[i].x,t[a].points[o].y+t[a].points[i].y)})}return n}_testrightangle(t,n,o,i,e,s){return t.points[i].x===t.points[n].x&&t.points[i].x===t.points[o].x&&t.points[i].y===t.points[e].y&&t.points[i].y===t.points[s].y||t.points[i].y===t.points[n].y&&t.points[i].y===t.points[o].y&&t.points[i].x===t.points[e].x&&t.points[i].x===t.points[s].x}_getdirection(t,n,o,i){return t<o?n<i?f:w:t>o?n<i?b:n>i?x:m:n<i?u:n>i?y:M}_tracePath(t){let e=0;const s=[],a=[];for(;e<t.points.length;){const n=t.points[e].direction;let o=_,i=e+1;for(;(t.points[i].direction===n||t.points[i].direction===o||-1===o)&&i<t.points.length-1;)t.points[i].direction!==n&&o===_&&(o=t.points[i].direction||g),i++;i===t.points.length-1?(s.push(...this._fitseq(t,e,0)),a.push(...this._fitseq(t,e,0,!0)),e=t.points.length):(s.push(...this._fitseq(t,e,i)),a.push(...this._fitseq(t,e,i,!0)),e=i)}const r=[new n(new o(t.points[0].x,t.points[0].y)),...s,new i];a.reverse();const h=a[a.length-1].values.slice(0,2);return{commands:r,holeCommands:[new n(new o(h[0],h[1])),...a,new i],holechildren:t.holechildren,isholepath:t.isholepath}}_fitseq(t,n,i,a){const r=this.ltres,h=this.qtres;if(i>t.points.length||i<0)return[];let l,d,p,c=n,g=0,f=!0,u=i-n;u<0&&(u+=t.points.length);const b=(t.points[i].x-t.points[n].x)/u,m=(t.points[i].y-t.points[n].y)/u;let x=(n+1)%t.points.length;for(;x!=i;){let o=x-n;o<0&&(o+=t.points.length),l=t.points[n].x+b*o,d=t.points[n].y+m*o,p=(t.points[x].x-l)*(t.points[x].x-l)+(t.points[x].y-d)*(t.points[x].y-d),p>r&&(f=!1),p>g&&(c=x,g=p),x=(x+1)%t.points.length}if(f)return[new e(a?new o(t.points[n].x,t.points[n].y):new o(t.points[i].x,t.points[i].y))];const y=c;f=!0,g=0;let w=(y-n)/u,M=(1-w)*(1-w),_=2*(1-w)*w,v=w*w;const q=(M*t.points[n].x+v*t.points[i].x-t.points[y].x)/-_,A=(M*t.points[n].y+v*t.points[i].y-t.points[y].y)/-_;for(x=n+1;x!=i;)w=(x-n)/u,M=(1-w)*(1-w),_=2*(1-w)*w,v=w*w,l=M*t.points[n].x+_*q+v*t.points[i].x,d=M*t.points[n].y+_*A+v*t.points[i].y,p=(t.points[x].x-l)*(t.points[x].x-l)+(t.points[x].y-d)*(t.points[x].y-d),p>h&&(f=!1),p>g&&(c=x,g=p),x=(x+1)%t.points.length;if(f)return[new s([new o(q,A),new o(t.points[i].x,t.points[i].y)])];const C=y;return this._fitseq(t,n,C,a).concat(this._fitseq(t,C,i,a))}_complementCommand(t,n){const o=t[n],i=[];for(let n=0;n<o.holechildren.length;n++)i.push(...t[o.holechildren[n]].holeCommands);return i}_createPaths(t){const n=[];for(let o=0;o<t.length;o++)for(let i=0;i<t[o].length;i++){const e=t[o],s=e[i];if(s.isholepath||s.commands.length<this.commandOmit)continue;const r=this.palettes[o],h=`rgb(${r.r}, ${r.g}, ${r.b})`,l=new a({...this.pathAttrs,stroke:h,fill:h,opacity:String(r.a/255)});l.addCommand([...s.commands,...this._complementCommand(e,i)]),n.push(l)}return n}}export{d as Blur,p as ImgLoader,A as ImgTrace,c as Palette};
//# sourceMappingURL=index.js.map
