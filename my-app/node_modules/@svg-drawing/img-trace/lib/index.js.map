{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/utils/convertRGBAImage.ts","../src/blur.ts","../src/imgloader.ts","../src/palette.ts","../src/trace.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export const convertRGBAImage = (imgd: ImageData): ImageData => {\n  const pixelnum = imgd.width * imgd.height\n  const isRGB = imgd.data.length < pixelnum * 4\n  if (!isRGB) return imgd\n\n  const rgbaImgd = new Uint8ClampedArray(pixelnum * 4)\n  for (let pxcnt = 0; pxcnt < pixelnum; pxcnt++) {\n    rgbaImgd[pxcnt * 4] = imgd.data[pxcnt * 3]\n    rgbaImgd[pxcnt * 4 + 1] = imgd.data[pxcnt * 3 + 1]\n    rgbaImgd[pxcnt * 4 + 2] = imgd.data[pxcnt * 3 + 2]\n    rgbaImgd[pxcnt * 4 + 3] = 255\n  }\n  return {\n    ...imgd,\n    data: rgbaImgd,\n  }\n}\n","import { convertRGBAImage } from './utils/convertRGBAImage'\n\n// Gaussian kernels for blur\nconst gks: number[][] = [\n  [0.27901, 0.44198, 0.27901],\n  [0.135336, 0.228569, 0.272192, 0.228569, 0.135336],\n  [0.086776, 0.136394, 0.178908, 0.195843, 0.178908, 0.136394, 0.086776],\n  [\n    0.063327, 0.093095, 0.122589, 0.144599, 0.152781, 0.144599, 0.122589,\n    0.093095, 0.063327,\n  ],\n  [\n    0.049692, 0.069304, 0.089767, 0.107988, 0.120651, 0.125194, 0.120651,\n    0.107988, 0.089767, 0.069304, 0.049692,\n  ],\n]\n\nexport interface BlurOption {\n  radius?: number\n  delta?: number\n}\nexport class Blur {\n  public radius: number\n  public delta: number\n  constructor({ radius, delta }: BlurOption) {\n    this.radius = radius ?? 0\n    this.delta = delta ?? 20\n  }\n\n  public apply(argimgd: ImageData): ImageData {\n    const imgd = convertRGBAImage(argimgd)\n    const data: Uint8ClampedArray = new Uint8ClampedArray(imgd.data)\n    // radius and delta limits, this kernel\n    let radius = Math.floor(this.radius)\n    if (radius < 1) {\n      return imgd\n    }\n    if (radius > gks.length) {\n      radius = gks.length\n    }\n    let delta = Math.abs(this.delta)\n    if (delta > 1024) {\n      delta = 1024\n    }\n    const thisgk = gks[radius - 1]\n\n    // loop through all pixels, horizontal blur\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        let racc = 0\n        let gacc = 0\n        let bacc = 0\n        let aacc = 0\n        let wacc = 0\n        // gauss kernel loop\n        for (let k = -radius; k < radius + 1; k++) {\n          // add weighted color values\n          if (i + k > 0 && i + k < imgd.width) {\n            const idx = (j * imgd.width + i + k) * 4\n            racc += imgd.data[idx] * thisgk[k + radius]\n            gacc += imgd.data[idx + 1] * thisgk[k + radius]\n            bacc += imgd.data[idx + 2] * thisgk[k + radius]\n            aacc += imgd.data[idx + 3] * thisgk[k + radius]\n            wacc += thisgk[k + radius]\n          }\n        }\n        // The new pixel\n        const idx = (j * imgd.width + i) * 4\n        data[idx] = Math.floor(racc / wacc)\n        data[idx + 1] = Math.floor(gacc / wacc)\n        data[idx + 2] = Math.floor(bacc / wacc)\n        data[idx + 3] = Math.floor(aacc / wacc)\n      } // End of width loop\n    } // End of horizontal blur\n\n    // copying the half blurred imgd2\n    const himgd = new Uint8ClampedArray(data)\n\n    // loop through all pixels, vertical blur\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        let racc = 0\n        let gacc = 0\n        let bacc = 0\n        let aacc = 0\n        let wacc = 0\n        // gauss kernel loop\n        for (let k = -radius; k < radius + 1; k++) {\n          // add weighted color values\n          if (j + k > 0 && j + k < imgd.height) {\n            const idx = ((j + k) * imgd.width + i) * 4\n            racc += himgd[idx] * thisgk[k + radius]\n            gacc += himgd[idx + 1] * thisgk[k + radius]\n            bacc += himgd[idx + 2] * thisgk[k + radius]\n            aacc += himgd[idx + 3] * thisgk[k + radius]\n            wacc += thisgk[k + radius]\n          }\n        }\n        // The new pixel\n        const idx = (j * imgd.width + i) * 4\n        data[idx] = Math.floor(racc / wacc)\n        data[idx + 1] = Math.floor(gacc / wacc)\n        data[idx + 2] = Math.floor(bacc / wacc)\n        data[idx + 3] = Math.floor(aacc / wacc)\n      } // End of width loop\n    } // End of vertical blur\n    // Selective blur: loop through all pixels\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        const idx = (j * imgd.width + i) * 4\n        // d is the difference between the blurred and the original pixel\n        const d =\n          Math.abs(data[idx] - imgd.data[idx]) +\n          Math.abs(data[idx + 1] - imgd.data[idx + 1]) +\n          Math.abs(data[idx + 2] - imgd.data[idx + 2]) +\n          Math.abs(data[idx + 3] - imgd.data[idx + 3])\n        // selective blur: if d>delta, put the original pixel back\n        if (d > delta) {\n          data[idx] = imgd.data[idx]\n          data[idx + 1] = imgd.data[idx + 1]\n          data[idx + 2] = imgd.data[idx + 2]\n          data[idx + 3] = imgd.data[idx + 3]\n        }\n      }\n    } // End of Selective blur\n    return new ImageData(data, imgd.width, imgd.height)\n  }\n}\n","interface ImgLoaderOption {\n  corsenabled: boolean\n}\n\nexport class ImgLoader {\n  public corsenabled: boolean\n\n  constructor(options: Partial<ImgLoaderOption>) {\n    this.corsenabled = options.corsenabled ?? true\n  }\n\n  // TODO: improve types.\n  // if exists callback, return void. if not existed callback, return Promise<ImageData>.\n  public fromUrl(\n    url: string,\n    callback?: (imgd: ImageData) => void\n  ): void | Promise<ImageData> {\n    // TODO: cors improve\n    // const xhr = new XMLHttpRequest()\n    // xhr.responseType = 'blob'\n    // xhr.open('GET', url, true)\n    // xhr.onload = function() {\n    //   const img = new Image()\n    //   img.onload = function() {\n    //     this.loadImageElement(img, callback)\n    //   }\n    //   img.onerror = (err: any) => {\n    //     console.log(err)\n    //   }\n    //   console.log(this.response)\n\n    //   img.src = URL.createObjectURL(this.response)\n    // }\n    // xhr.onerror = (err: any) => console.log(err)\n    // xhr.send(null)\n    const load = (\n      resolve: (imgd: ImageData) => void,\n      reject?: (a: any) => void\n    ) => {\n      const img = new Image()\n      if (this.corsenabled) {\n        img.crossOrigin = 'Anonymous'\n      }\n      img.onload = () => {\n        this.fromImageElement(img, resolve)\n      }\n      img.onerror = (err: any) => {\n        if (reject) {\n          reject(err)\n        } else {\n          console.error(err)\n        }\n      }\n      img.src = url\n    }\n    if (callback) {\n      load(callback)\n    } else {\n      return new Promise(load)\n    }\n  }\n\n  // TODO: improve types.\n  // if exists callback, return void. if not existed callback, return Promise<ImageData>.\n  public fromImageElement(\n    img: HTMLImageElement,\n    callback?: (imgd: ImageData) => void\n  ): Promise<ImageData> | void {\n    const load = (\n      resolve: (imgd: ImageData) => void,\n      reject?: (a: any) => void\n    ) => {\n      const canvas = document.createElement('canvas')\n      canvas.width = img.naturalWidth || img.width\n      canvas.height = img.naturalHeight || img.height\n      const context = canvas.getContext('2d')\n      context?.drawImage(img, 0, 0)\n      const imgd: ImageData | undefined = context?.getImageData(\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      )\n      if (!imgd) {\n        if (reject) {\n          reject('error canvas context.')\n          return\n        } else {\n          throw 'error canvas context.'\n        }\n      }\n      resolve(imgd)\n    }\n    if (callback) {\n      load(callback)\n    } else {\n      return new Promise(load)\n    }\n  }\n}\n","import { convertRGBAImage } from './utils/convertRGBAImage'\n\nexport interface Rgba {\n  r: number\n  g: number\n  b: number\n  a: number\n}\n\nconst DEFAULT_NUMBER_OF_COLORS = 16\nexport interface FromImageDataOptions {\n  numberOfColors?: number\n  colorQuantCycles?: number\n}\nexport class Palette {\n  // Deterministic sampling a palette from imagedata: rectangular grid\n  public static imageData(\n    argimgd: ImageData,\n    { numberOfColors, colorQuantCycles }: FromImageDataOptions = {}\n  ): Rgba[] {\n    const nc = numberOfColors || DEFAULT_NUMBER_OF_COLORS\n    const cqc = colorQuantCycles || 3\n    const imgd = convertRGBAImage(argimgd)\n\n    const palette = this._deterministic(imgd, nc)\n    let paletteacc: {\n      r: number\n      g: number\n      b: number\n      a: number\n      n: number\n    }[] = []\n    // Using a form of k-means clustering repeatead options.colorquantcycles times. http://en.wikipedia.org/wiki/Color_quantization\n    for (let cnt = 0; cnt < cqc; cnt++) {\n      if (cnt > 0) {\n        for (let k = 0; k < palette.length; k++) {\n          // averaging\n          if (paletteacc[k].n > 0) {\n            palette[k] = {\n              r: Math.floor(paletteacc[k].r / paletteacc[k].n),\n              g: Math.floor(paletteacc[k].g / paletteacc[k].n),\n              b: Math.floor(paletteacc[k].b / paletteacc[k].n),\n              a: Math.floor(paletteacc[k].a / paletteacc[k].n),\n            }\n          }\n        }\n      }\n\n      paletteacc = Array.from({ length: palette.length }, () => ({\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n        n: 0,\n      }))\n\n      // loop through all pixels\n      for (let j = 0; j < imgd.height; j++) {\n        for (let i = 0; i < imgd.width; i++) {\n          // pixel index\n          const idx = (j * imgd.width + i) * 4\n\n          // find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors\n          // In my experience, https://en.wikipedia.org/wiki/Rectilinear_distance works better than https://en.wikipedia.org/wiki/Euclidean_distance\n          let cdl = 1024 // 4 * 256 is the maximum RGBA distance\n          const ci = palette.reduce((findId: number, pal: Rgba, id: number) => {\n            const cd =\n              Math.abs(pal.r - imgd.data[idx]) +\n              Math.abs(pal.g - imgd.data[idx + 1]) +\n              Math.abs(pal.b - imgd.data[idx + 2]) +\n              Math.abs(pal.a - imgd.data[idx + 3])\n            if (cd < cdl) {\n              cdl = cd\n              return id\n            }\n            return findId\n          }, 0)\n\n          // add to palettacc\n          paletteacc[ci].r += imgd.data[idx]\n          paletteacc[ci].g += imgd.data[idx + 1]\n          paletteacc[ci].b += imgd.data[idx + 2]\n          paletteacc[ci].a += imgd.data[idx + 3]\n          paletteacc[ci].n += 1\n        }\n      }\n    }\n    return palette\n  }\n\n  // Deterministic sampling a palette from imagedata: rectangular grid\n  private static _deterministic(\n    imgd: ImageData,\n    numberOfColors: number\n  ): Rgba[] {\n    const palette: Rgba[] = []\n    const ni = Math.ceil(Math.sqrt(numberOfColors))\n    const nj = Math.ceil(numberOfColors / ni)\n    const vx = imgd.width / (ni + 1)\n    const vy = imgd.height / (nj + 1)\n    for (let j = 0; j < nj; j++) {\n      for (let i = 0; i < ni; i++) {\n        if (palette.length === numberOfColors) break\n        const idx = Math.floor((j + 1) * vy * imgd.width + (i + 1) * vx) * 4\n        palette.push({\n          r: imgd.data[idx],\n          g: imgd.data[idx + 1],\n          b: imgd.data[idx + 2],\n          a: imgd.data[idx + 3],\n        })\n      }\n    }\n    return palette\n  }\n  // Generating a palette with number of colors\n  public static number(\n    numberofcolors: number = DEFAULT_NUMBER_OF_COLORS\n  ): Rgba[] {\n    if (numberofcolors < 8) return this.grey(numberofcolors)\n    const palette: Rgba[] = []\n    const colorqnum = Math.floor(Math.pow(numberofcolors, 1 / 3))\n    const colorstep = Math.floor(255 / (colorqnum - 1))\n\n    for (let r = 0; r < colorqnum; r += 1) {\n      for (let g = 0; g < colorqnum; g += 1) {\n        for (let b = 0; b < colorqnum; b += 1) {\n          palette.push({\n            r: r * colorstep,\n            g: g * colorstep,\n            b: b * colorstep,\n            a: 255,\n          })\n        }\n      }\n    }\n\n    // TODO: rest improve\n    // TODO: test\n    const rest = numberofcolors - colorqnum * colorqnum * colorqnum\n    for (let rcnt = 0; rcnt < rest; rcnt++) {\n      palette.push({\n        r: Math.floor(Math.random() * 255),\n        g: Math.floor(Math.random() * 255),\n        b: Math.floor(Math.random() * 255),\n        a: Math.floor(Math.random() * 255),\n      })\n    }\n\n    return palette\n  }\n\n  public static grey(\n    numberofcolors: number = DEFAULT_NUMBER_OF_COLORS\n  ): Rgba[] {\n    const palette: Rgba[] = []\n    const graystep = Math.floor(255 / (numberofcolors - 1))\n    for (let i = 0; i < numberofcolors; i++) {\n      palette.push({\n        r: i * graystep,\n        g: i * graystep,\n        b: i * graystep,\n        a: 255,\n      })\n    }\n\n    return palette\n  }\n}\n","import {\n  Svg,\n  Path,\n  Move,\n  Close,\n  Point,\n  Line,\n  QuadraticCurve,\n} from '@svg-drawing/core'\nimport { convertRGBAImage } from './utils/convertRGBAImage'\nimport type { Rgba } from './palette'\nimport type { CommandClass, PathClass, PathAttributes } from '@svg-drawing/core'\n\ntype ColorQuantization = number[][]\n// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n// 12    ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n// 48    ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n// Type  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\ntype EdgeType =\n  | -1 // Empty\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\ntype EdgeLayer = EdgeType[][]\n\ninterface PathInfo {\n  commands: CommandClass[]\n  holeCommands: CommandClass[]\n  holechildren: number[]\n  isholepath: boolean\n}\ninterface PointInfo {\n  points: DirectionPoint[]\n  boundingbox: [number, number, number, number]\n  holechildren: number[]\n  isholepath: boolean\n}\n\ntype DirectionValue = typeof DIRECTION_TYPE[keyof typeof DIRECTION_TYPE]\nconst DIRECTION_TYPE = {\n  RIGHT: 0,\n  RIGHT_BOTTOM: 1,\n  BOTTOM: 2,\n  LEFT_BOTTOM: 3,\n  LEFT: 4,\n  LEFT_TOP: 5,\n  TOP: 6,\n  RIGHT_TOP: 7,\n  CENTER: 8,\n  EMPTY: -1,\n} as const\ninterface DirectionPoint {\n  x: number\n  y: number\n  direction: DirectionValue\n}\n\nexport interface ImgTraceOption {\n  // Tracing\n  ltres?: number\n  qtres?: number\n  rightangleenhance?: boolean\n  // filter\n  pathOmit?: number\n  commandOmit?: number\n  // override path element attribute\n  pathAttrs?: PathAttributes\n  palettes?: Rgba[]\n}\n\nconst pathscanCombinedLookup: EdgeType[][][] = [\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ], // arr[py][px]===0 is invalid\n  [\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [0, 0, 1, 0],\n  ],\n  [\n    [0, 0, 1, 0],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [-1, -1, -1, -1],\n    [0, 0, 1, 0],\n    [0, 3, 0, 1],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [13, 3, 0, 1],\n    [13, 2, -1, 0],\n    [7, 1, 0, -1],\n    [7, 0, 1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [0, 3, 0, 1],\n  ],\n  [\n    [0, 3, 0, 1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [0, 3, 0, 1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [0, 3, 0, 1],\n  ],\n  [\n    [11, 1, 0, -1],\n    [14, 0, 1, 0],\n    [14, 3, 0, 1],\n    [11, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 0, 1, 0],\n    [0, 3, 0, 1],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [0, 0, 1, 0],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [0, 0, 1, 0],\n  ],\n  [\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ], // arr[py][px]===15 is invalid\n]\n\nconst DEFAULT_PALETTES = [\n  { r: 0, g: 0, b: 0, a: 255 },\n  { r: 50, g: 50, b: 50, a: 255 },\n  { r: 100, g: 100, b: 100, a: 255 },\n  { r: 150, g: 150, b: 150, a: 255 },\n  { r: 200, g: 200, b: 200, a: 255 },\n]\n\nexport class ImgTrace {\n  // Tracing\n  public ltres: number\n  public qtres: number\n  public rightangleenhance: boolean\n  // Filter\n  public pathOmit: number\n  public commandOmit: number\n  // Path element attribute\n  public pathAttrs: PathAttributes\n  // Palettes\n  public palettes: Rgba[]\n\n  // creating options object, setting defaults for missing values\n  constructor(opts: ImgTraceOption = {}) {\n    // Tracing\n    this.ltres = opts.ltres ?? 1\n    this.qtres = opts.qtres ?? 1\n    this.rightangleenhance = opts.rightangleenhance ?? true\n\n    // Filter\n    this.pathOmit = opts.pathOmit ?? 8\n    this.commandOmit = opts.commandOmit ?? 0\n\n    // SVG rendering\n    this.pathAttrs = { strokeWidth: '1', ...(opts.pathAttrs || {}) }\n\n    // Palette\n    this.palettes = opts.palettes || DEFAULT_PALETTES\n  }\n\n  public load(argImgd: ImageData): Svg {\n    const imgd = convertRGBAImage(argImgd)\n    const cq = this._colorQuantization(imgd)\n    const pathLayer: PathInfo[][] = []\n    for (let paletteId = 0; paletteId < this.palettes.length; paletteId++) {\n      const edge = this._edgeDetection(cq, paletteId)\n      const path = this._pathScan(edge)\n      const interporation = this._interpolation(path)\n      const tracedpath = interporation.map(this._tracePath.bind(this))\n      pathLayer.push(tracedpath)\n    }\n    const paths = this._createPaths(pathLayer)\n    return new Svg({\n      width: cq[0].length - 2,\n      height: cq.length - 2,\n    }).addPath(paths)\n  }\n\n  private _colorQuantization(imgd: ImageData): ColorQuantization {\n    return Array.from({ length: imgd.height + 2 }, (_h, j) =>\n      Array.from({ length: imgd.width + 2 }, (_w, i) => {\n        if (\n          i === 0 ||\n          i === imgd.width + 1 ||\n          j === 0 ||\n          j === imgd.height + 1\n        ) {\n          return -1\n        }\n        // pixel index\n        const h = j - 1\n        const w = i - 1\n        const idx = (h * imgd.width + w) * 4\n        return this._findPaletteIndex({\n          r: imgd.data[idx],\n          g: imgd.data[idx + 1],\n          b: imgd.data[idx + 2],\n          a: imgd.data[idx + 3],\n        })\n      })\n    )\n  }\n\n  /**\n   * Find similar color from palette and return ID\n   *\n   * @param {Rgba} color Pixel color\n   */\n  private _findPaletteIndex({ r, g, b, a }: Rgba): number {\n    let cdl = 1024 // 4 * 256 is the maximum RGBA distance\n    return this.palettes.reduce((findId, pal, id) => {\n      const cd =\n        Math.abs(pal.r - r) +\n        Math.abs(pal.g - g) +\n        Math.abs(pal.b - b) +\n        Math.abs(pal.a - a)\n      if (cd < cdl) {\n        cdl = cd\n        return id\n      }\n      return findId\n    }, 0)\n  }\n\n  private _edgeDetection(cq: ColorQuantization, palId: number): EdgeLayer {\n    const res: EdgeLayer = []\n    const ah = cq.length\n    const aw = cq[0].length\n\n    for (let h = 0; h < ah; h++) {\n      res[h] = []\n      for (let w = 0; w < aw; w++) {\n        res[h][w] =\n          h === 0 || w === 0\n            ? 0\n            : (((cq[h - 1][w - 1] === palId ? 1 : 0) +\n                (cq[h - 1][w] === palId ? 2 : 0) +\n                (cq[h][w - 1] === palId ? 8 : 0) +\n                (cq[h][w] === palId ? 4 : 0)) as EdgeType)\n      }\n    }\n\n    return res\n  }\n\n  private _pointpoly(p: DirectionPoint, pa: DirectionPoint[]): boolean {\n    let isin = false\n\n    for (let i = 0, j = pa.length - 1; i < pa.length; j = i++) {\n      isin =\n        pa[i].y > p.y !== pa[j].y > p.y &&\n        p.x <\n          ((pa[j].x - pa[i].x) * (p.y - pa[i].y)) / (pa[j].y - pa[i].y) +\n            pa[i].x\n          ? !isin\n          : isin\n    }\n\n    return isin\n  }\n\n  private _pathScan(edge: EdgeLayer): PointInfo[] {\n    const width = edge[0].length\n    const height = edge.length\n    const paths: PointInfo[] = []\n    let pacnt = 0\n\n    for (let h = 0; h < height; h++) {\n      for (let w = 0; w < width; w++) {\n        // Related for edgeDetection methods\n        const edgeType = edge[h][w]\n        if (edgeType !== 4 && edgeType !== 11) {\n          continue\n        }\n        let px = w\n        let py = h\n        let dir = 1\n        let pcnt = 0\n        let pathfinished = false\n        paths[pacnt] = {\n          points: [],\n          boundingbox: [px, py, px, py],\n          holechildren: [],\n          isholepath: false,\n        }\n\n        while (!pathfinished) {\n          paths[pacnt].points[pcnt] = {\n            x: px - 1,\n            y: py - 1,\n            direction: DIRECTION_TYPE.EMPTY,\n          }\n\n          if (px - 1 < paths[pacnt].boundingbox[0]) {\n            paths[pacnt].boundingbox[0] = px - 1\n          }\n          if (px - 1 > paths[pacnt].boundingbox[2]) {\n            paths[pacnt].boundingbox[2] = px - 1\n          }\n          if (py - 1 < paths[pacnt].boundingbox[1]) {\n            paths[pacnt].boundingbox[1] = py - 1\n          }\n          if (py - 1 > paths[pacnt].boundingbox[3]) {\n            paths[pacnt].boundingbox[3] = py - 1\n          }\n\n          const lookuprow = pathscanCombinedLookup[edge[py][px]][dir]\n          edge[py][px] = lookuprow[0]\n          dir = lookuprow[1]\n          px += lookuprow[2]\n          py += lookuprow[3]\n\n          // Close path\n          if (\n            px - 1 === paths[pacnt].points[0].x &&\n            py - 1 === paths[pacnt].points[0].y\n          ) {\n            pathfinished = true\n\n            if (paths[pacnt].points.length < this.pathOmit) {\n              paths.pop()\n            } else {\n              if (edgeType === 11) {\n                paths[pacnt].isholepath = true\n                let parentidx = 0\n                let parentbbox = [-1, -1, width + 1, height + 1]\n                for (let parentcnt = 0; parentcnt < pacnt; parentcnt++) {\n                  if (\n                    !paths[parentcnt].isholepath &&\n                    this._boundingboxincludes(\n                      paths[parentcnt].boundingbox,\n                      paths[pacnt].boundingbox\n                    ) &&\n                    this._boundingboxincludes(\n                      parentbbox,\n                      paths[parentcnt].boundingbox\n                    ) &&\n                    this._pointpoly(\n                      paths[pacnt].points[0],\n                      paths[parentcnt].points\n                    )\n                  ) {\n                    parentidx = parentcnt\n                    parentbbox = paths[parentcnt].boundingbox\n                  }\n                }\n                paths[parentidx].holechildren.push(pacnt)\n              }\n              pacnt++\n            }\n          }\n          pcnt++\n        }\n      }\n    }\n\n    return paths\n  }\n\n  private _boundingboxincludes(\n    parentbbox: number[],\n    childbbox: number[]\n  ): boolean {\n    return (\n      parentbbox[0] < childbbox[0] &&\n      parentbbox[1] < childbbox[1] &&\n      parentbbox[2] > childbbox[2] &&\n      parentbbox[3] > childbbox[3]\n    )\n  }\n  private _interpolation(paths: PointInfo[]): PointInfo[] {\n    const ins: PointInfo[] = []\n    let nextidx = 0\n    let nextidx2 = 0\n    let previdx = 0\n    let previdx2 = 0\n\n    for (let pacnt = 0; pacnt < paths.length; pacnt++) {\n      ins[pacnt] = {\n        points: [],\n        boundingbox: paths[pacnt].boundingbox,\n        holechildren: paths[pacnt].holechildren,\n        isholepath: paths[pacnt].isholepath,\n      }\n      const palen = paths[pacnt].points.length\n\n      for (let pcnt = 0; pcnt < palen; pcnt++) {\n        nextidx = (pcnt + 1) % palen\n        nextidx2 = (pcnt + 2) % palen\n        previdx = (pcnt - 1 + palen) % palen\n        previdx2 = (pcnt - 2 + palen) % palen\n\n        if (\n          this.rightangleenhance &&\n          this._testrightangle(\n            paths[pacnt],\n            previdx2,\n            previdx,\n            pcnt,\n            nextidx,\n            nextidx2\n          )\n        ) {\n          if (ins[pacnt].points.length > 0) {\n            ins[pacnt].points[ins[pacnt].points.length - 1].direction =\n              this._getdirection(\n                ins[pacnt].points[ins[pacnt].points.length - 1].x,\n                ins[pacnt].points[ins[pacnt].points.length - 1].y,\n                paths[pacnt].points[pcnt].x,\n                paths[pacnt].points[pcnt].y\n              )\n          }\n\n          ins[pacnt].points.push({\n            x: paths[pacnt].points[pcnt].x,\n            y: paths[pacnt].points[pcnt].y,\n            direction: this._getdirection(\n              paths[pacnt].points[pcnt].x,\n              paths[pacnt].points[pcnt].y,\n              (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) /\n                2,\n              (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2\n            ),\n          })\n        }\n\n        ins[pacnt].points.push({\n          x: (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2,\n          y: (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2,\n          direction: this._getdirection(\n            paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x,\n            paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y,\n            paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x,\n            paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y\n          ),\n        })\n      }\n    }\n\n    return ins\n  }\n\n  private _testrightangle(\n    path: PointInfo,\n    idx1: number,\n    idx2: number,\n    idx3: number,\n    idx4: number,\n    idx5: number\n  ): boolean {\n    return (\n      (path.points[idx3].x === path.points[idx1].x &&\n        path.points[idx3].x === path.points[idx2].x &&\n        path.points[idx3].y === path.points[idx4].y &&\n        path.points[idx3].y === path.points[idx5].y) ||\n      (path.points[idx3].y === path.points[idx1].y &&\n        path.points[idx3].y === path.points[idx2].y &&\n        path.points[idx3].x === path.points[idx4].x &&\n        path.points[idx3].x === path.points[idx5].x)\n    )\n  }\n\n  private _getdirection(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number\n  ): DirectionValue {\n    if (x1 < x2) {\n      if (y1 < y2) {\n        return DIRECTION_TYPE.RIGHT_BOTTOM\n      }\n      if (y1 > y2) {\n        return DIRECTION_TYPE.RIGHT_TOP\n      }\n      return DIRECTION_TYPE.RIGHT_TOP\n    }\n    if (x1 > x2) {\n      if (y1 < y2) {\n        return DIRECTION_TYPE.LEFT_BOTTOM\n      }\n      if (y1 > y2) {\n        return DIRECTION_TYPE.LEFT_TOP\n      }\n      return DIRECTION_TYPE.LEFT\n    }\n\n    if (y1 < y2) {\n      return DIRECTION_TYPE.BOTTOM\n    }\n    if (y1 > y2) {\n      return DIRECTION_TYPE.TOP\n    }\n    return DIRECTION_TYPE.CENTER\n  }\n\n  private _tracePath(path: PointInfo): PathInfo {\n    let pcnt = 0\n    const comms: CommandClass[] = []\n    const holes: CommandClass[] = []\n    while (pcnt < path.points.length) {\n      // 5.1. Find sequences of points with only 2 segment types\n      const segtype1: DirectionValue = path.points[pcnt].direction\n      let segtype2: DirectionValue = DIRECTION_TYPE.EMPTY\n      let seqend = pcnt + 1\n      while (\n        (path.points[seqend].direction === segtype1 ||\n          path.points[seqend].direction === segtype2 ||\n          segtype2 === -1) &&\n        seqend < path.points.length - 1\n      ) {\n        if (\n          path.points[seqend].direction !== segtype1 &&\n          segtype2 === DIRECTION_TYPE.EMPTY\n        ) {\n          segtype2 = path.points[seqend].direction || DIRECTION_TYPE.RIGHT\n        }\n        seqend++\n      }\n\n      if (seqend === path.points.length - 1) {\n        comms.push(...this._fitseq(path, pcnt, 0))\n        holes.push(...this._fitseq(path, pcnt, 0, true))\n        pcnt = path.points.length\n      } else {\n        comms.push(...this._fitseq(path, pcnt, seqend))\n        holes.push(...this._fitseq(path, pcnt, seqend, true))\n        pcnt = seqend\n      }\n    }\n\n    const commands = [\n      new Move(new Point(path.points[0].x, path.points[0].y)),\n      ...comms,\n      new Close(),\n    ]\n    holes.reverse()\n    const value = holes[holes.length - 1].values.slice(0, 2)\n    const holeCommands = [\n      new Move(new Point(value[0], value[1])),\n      ...holes,\n      new Close(),\n    ]\n    return {\n      commands,\n      holeCommands,\n      holechildren: path.holechildren,\n      isholepath: path.isholepath,\n    }\n  }\n\n  private _fitseq(\n    path: PointInfo,\n    seqstart: number,\n    seqend: number,\n    isHolePath?: boolean\n  ): CommandClass[] {\n    const ltres = this.ltres\n    const qtres = this.qtres\n    if (seqend > path.points.length || seqend < 0) {\n      return []\n    }\n    let errorpoint = seqstart\n    let errorval = 0\n    let curvepass = true\n    let px\n    let py\n    let dist2\n    let tl = seqend - seqstart\n    if (tl < 0) {\n      tl += path.points.length\n    }\n    const vx = (path.points[seqend].x - path.points[seqstart].x) / tl\n    const vy = (path.points[seqend].y - path.points[seqstart].y) / tl\n\n    let pcnt = (seqstart + 1) % path.points.length\n    while (pcnt != seqend) {\n      let pl = pcnt - seqstart\n      if (pl < 0) {\n        pl += path.points.length\n      }\n      px = path.points[seqstart].x + vx * pl\n      py = path.points[seqstart].y + vy * pl\n      dist2 =\n        (path.points[pcnt].x - px) * (path.points[pcnt].x - px) +\n        (path.points[pcnt].y - py) * (path.points[pcnt].y - py)\n      if (dist2 > ltres) {\n        curvepass = false\n      }\n      if (dist2 > errorval) {\n        errorpoint = pcnt\n        errorval = dist2\n      }\n      pcnt = (pcnt + 1) % path.points.length\n    }\n\n    if (curvepass) {\n      return [\n        new Line(\n          isHolePath\n            ? new Point(path.points[seqstart].x, path.points[seqstart].y)\n            : new Point(path.points[seqend].x, path.points[seqend].y)\n        ),\n      ]\n    }\n\n    const fitpoint = errorpoint\n    curvepass = true\n    errorval = 0\n\n    let t = (fitpoint - seqstart) / tl\n    let t1 = (1 - t) * (1 - t)\n    let t2 = 2 * (1 - t) * t\n    let t3 = t * t\n    const cpx =\n      (t1 * path.points[seqstart].x +\n        t3 * path.points[seqend].x -\n        path.points[fitpoint].x) /\n      -t2\n    const cpy =\n      (t1 * path.points[seqstart].y +\n        t3 * path.points[seqend].y -\n        path.points[fitpoint].y) /\n      -t2\n\n    pcnt = seqstart + 1\n    while (pcnt != seqend) {\n      t = (pcnt - seqstart) / tl\n      t1 = (1 - t) * (1 - t)\n      t2 = 2 * (1 - t) * t\n      t3 = t * t\n      px = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x\n      py = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y\n\n      dist2 =\n        (path.points[pcnt].x - px) * (path.points[pcnt].x - px) +\n        (path.points[pcnt].y - py) * (path.points[pcnt].y - py)\n\n      if (dist2 > qtres) {\n        curvepass = false\n      }\n      if (dist2 > errorval) {\n        errorpoint = pcnt\n        errorval = dist2\n      }\n      pcnt = (pcnt + 1) % path.points.length\n    }\n    if (curvepass) {\n      return [\n        new QuadraticCurve([\n          new Point(cpx, cpy),\n          new Point(path.points[seqend].x, path.points[seqend].y),\n        ]),\n      ]\n    }\n    const splitpoint = fitpoint\n\n    return this._fitseq(path, seqstart, splitpoint, isHolePath).concat(\n      this._fitseq(path, splitpoint, seqend, isHolePath)\n    )\n  }\n\n  private _complementCommand(\n    info: PathInfo[],\n    layerIndex: number\n  ): CommandClass[] {\n    const p = info[layerIndex]\n    const complement = []\n    for (let hcnt = 0; hcnt < p.holechildren.length; hcnt++) {\n      complement.push(...info[p.holechildren[hcnt]].holeCommands)\n    }\n    return complement\n  }\n\n  private _createPaths(pathLayer: PathInfo[][]): PathClass[] {\n    const result: PathClass[] = []\n    for (let lcnt = 0; lcnt < pathLayer.length; lcnt++) {\n      for (let pcnt = 0; pcnt < pathLayer[lcnt].length; pcnt++) {\n        const layer = pathLayer[lcnt]\n        const smp = layer[pcnt]\n        if (smp.isholepath || smp.commands.length < this.commandOmit) continue\n        const rgba = this.palettes[lcnt]\n        const color = `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`\n        const path = new Path({\n          ...this.pathAttrs,\n          stroke: color,\n          fill: color,\n          opacity: String(rgba.a / 255.0),\n        })\n        path.addCommand([\n          ...smp.commands,\n          ...this._complementCommand(layer, pcnt),\n        ])\n        result.push(path)\n      }\n    }\n\n    return result\n  }\n}\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","convertRGBAImage","imgd","pixelnum","width","height","data","length","rgbaImgd","Uint8ClampedArray","pxcnt","gks","Blur","constructor","_ref","radius","delta","this","apply","argimgd","Math","floor","abs","thisgk","j","i","racc","gacc","bacc","aacc","wacc","k","idx","himgd","ImageData","ImgLoader","options","corsenabled","fromUrl","url","callback","load","resolve","reject","img","Image","crossOrigin","onload","fromImageElement","onerror","err","console","error","src","Promise","canvas","document","createElement","naturalWidth","naturalHeight","context","getContext","drawImage","getImageData","Palette","static","_temp","numberOfColors","colorQuantCycles","nc","cqc","palette","_deterministic","paletteacc","cnt","n","r","g","b","a","Array","from","cdl","ci","reduce","findId","pal","id","cd","ni","ceil","sqrt","nj","vx","vy","push","numberofcolors","grey","colorqnum","pow","colorstep","rest","rcnt","random","graystep","DIRECTION_TYPE","pathscanCombinedLookup","DEFAULT_PALETTES","ImgTrace","opts","ltres","qtres","rightangleenhance","pathOmit","commandOmit","pathAttrs","strokeWidth","palettes","argImgd","cq","_colorQuantization","pathLayer","paletteId","edge","_edgeDetection","path","_pathScan","tracedpath","_interpolation","map","_tracePath","bind","paths","_createPaths","Svg","addPath","_h","_w","w","_findPaletteIndex","palId","res","ah","aw","h","_pointpoly","p","pa","isin","y","x","pacnt","edgeType","px","py","dir","pcnt","pathfinished","points","boundingbox","holechildren","isholepath","direction","lookuprow","pop","parentidx","parentbbox","parentcnt","_boundingboxincludes","childbbox","ins","nextidx","nextidx2","previdx","previdx2","palen","_testrightangle","_getdirection","idx1","idx2","idx3","idx4","idx5","x1","y1","x2","y2","comms","holes","segtype1","segtype2","seqend","_fitseq","commands","Move","Point","Close","reverse","values","slice","holeCommands","seqstart","isHolePath","dist2","errorpoint","errorval","curvepass","tl","pl","Line","fitpoint","t","t1","t2","t3","cpx","cpy","QuadraticCurve","splitpoint","concat","_complementCommand","info","layerIndex","complement","hcnt","result","lcnt","layer","smp","rgba","color","Path","stroke","fill","opacity","String","addCommand"],"mappings":"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"}