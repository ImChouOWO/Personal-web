{"version":3,"file":"index.cjs","sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/@babel/runtime/helpers/esm/extends.js","../src/utils/convertRGBAImage.ts","../src/blur.ts","../src/imgloader.ts","../src/palette.ts","../src/trace.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export const convertRGBAImage = (imgd: ImageData): ImageData => {\n  const pixelnum = imgd.width * imgd.height\n  const isRGB = imgd.data.length < pixelnum * 4\n  if (!isRGB) return imgd\n\n  const rgbaImgd = new Uint8ClampedArray(pixelnum * 4)\n  for (let pxcnt = 0; pxcnt < pixelnum; pxcnt++) {\n    rgbaImgd[pxcnt * 4] = imgd.data[pxcnt * 3]\n    rgbaImgd[pxcnt * 4 + 1] = imgd.data[pxcnt * 3 + 1]\n    rgbaImgd[pxcnt * 4 + 2] = imgd.data[pxcnt * 3 + 2]\n    rgbaImgd[pxcnt * 4 + 3] = 255\n  }\n  return {\n    ...imgd,\n    data: rgbaImgd,\n  }\n}\n","import { convertRGBAImage } from './utils/convertRGBAImage'\n\n// Gaussian kernels for blur\nconst gks: number[][] = [\n  [0.27901, 0.44198, 0.27901],\n  [0.135336, 0.228569, 0.272192, 0.228569, 0.135336],\n  [0.086776, 0.136394, 0.178908, 0.195843, 0.178908, 0.136394, 0.086776],\n  [\n    0.063327, 0.093095, 0.122589, 0.144599, 0.152781, 0.144599, 0.122589,\n    0.093095, 0.063327,\n  ],\n  [\n    0.049692, 0.069304, 0.089767, 0.107988, 0.120651, 0.125194, 0.120651,\n    0.107988, 0.089767, 0.069304, 0.049692,\n  ],\n]\n\nexport interface BlurOption {\n  radius?: number\n  delta?: number\n}\nexport class Blur {\n  public radius: number\n  public delta: number\n  constructor({ radius, delta }: BlurOption) {\n    this.radius = radius ?? 0\n    this.delta = delta ?? 20\n  }\n\n  public apply(argimgd: ImageData): ImageData {\n    const imgd = convertRGBAImage(argimgd)\n    const data: Uint8ClampedArray = new Uint8ClampedArray(imgd.data)\n    // radius and delta limits, this kernel\n    let radius = Math.floor(this.radius)\n    if (radius < 1) {\n      return imgd\n    }\n    if (radius > gks.length) {\n      radius = gks.length\n    }\n    let delta = Math.abs(this.delta)\n    if (delta > 1024) {\n      delta = 1024\n    }\n    const thisgk = gks[radius - 1]\n\n    // loop through all pixels, horizontal blur\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        let racc = 0\n        let gacc = 0\n        let bacc = 0\n        let aacc = 0\n        let wacc = 0\n        // gauss kernel loop\n        for (let k = -radius; k < radius + 1; k++) {\n          // add weighted color values\n          if (i + k > 0 && i + k < imgd.width) {\n            const idx = (j * imgd.width + i + k) * 4\n            racc += imgd.data[idx] * thisgk[k + radius]\n            gacc += imgd.data[idx + 1] * thisgk[k + radius]\n            bacc += imgd.data[idx + 2] * thisgk[k + radius]\n            aacc += imgd.data[idx + 3] * thisgk[k + radius]\n            wacc += thisgk[k + radius]\n          }\n        }\n        // The new pixel\n        const idx = (j * imgd.width + i) * 4\n        data[idx] = Math.floor(racc / wacc)\n        data[idx + 1] = Math.floor(gacc / wacc)\n        data[idx + 2] = Math.floor(bacc / wacc)\n        data[idx + 3] = Math.floor(aacc / wacc)\n      } // End of width loop\n    } // End of horizontal blur\n\n    // copying the half blurred imgd2\n    const himgd = new Uint8ClampedArray(data)\n\n    // loop through all pixels, vertical blur\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        let racc = 0\n        let gacc = 0\n        let bacc = 0\n        let aacc = 0\n        let wacc = 0\n        // gauss kernel loop\n        for (let k = -radius; k < radius + 1; k++) {\n          // add weighted color values\n          if (j + k > 0 && j + k < imgd.height) {\n            const idx = ((j + k) * imgd.width + i) * 4\n            racc += himgd[idx] * thisgk[k + radius]\n            gacc += himgd[idx + 1] * thisgk[k + radius]\n            bacc += himgd[idx + 2] * thisgk[k + radius]\n            aacc += himgd[idx + 3] * thisgk[k + radius]\n            wacc += thisgk[k + radius]\n          }\n        }\n        // The new pixel\n        const idx = (j * imgd.width + i) * 4\n        data[idx] = Math.floor(racc / wacc)\n        data[idx + 1] = Math.floor(gacc / wacc)\n        data[idx + 2] = Math.floor(bacc / wacc)\n        data[idx + 3] = Math.floor(aacc / wacc)\n      } // End of width loop\n    } // End of vertical blur\n    // Selective blur: loop through all pixels\n    for (let j = 0; j < imgd.height; j++) {\n      for (let i = 0; i < imgd.width; i++) {\n        const idx = (j * imgd.width + i) * 4\n        // d is the difference between the blurred and the original pixel\n        const d =\n          Math.abs(data[idx] - imgd.data[idx]) +\n          Math.abs(data[idx + 1] - imgd.data[idx + 1]) +\n          Math.abs(data[idx + 2] - imgd.data[idx + 2]) +\n          Math.abs(data[idx + 3] - imgd.data[idx + 3])\n        // selective blur: if d>delta, put the original pixel back\n        if (d > delta) {\n          data[idx] = imgd.data[idx]\n          data[idx + 1] = imgd.data[idx + 1]\n          data[idx + 2] = imgd.data[idx + 2]\n          data[idx + 3] = imgd.data[idx + 3]\n        }\n      }\n    } // End of Selective blur\n    return new ImageData(data, imgd.width, imgd.height)\n  }\n}\n","interface ImgLoaderOption {\n  corsenabled: boolean\n}\n\nexport class ImgLoader {\n  public corsenabled: boolean\n\n  constructor(options: Partial<ImgLoaderOption>) {\n    this.corsenabled = options.corsenabled ?? true\n  }\n\n  // TODO: improve types.\n  // if exists callback, return void. if not existed callback, return Promise<ImageData>.\n  public fromUrl(\n    url: string,\n    callback?: (imgd: ImageData) => void\n  ): void | Promise<ImageData> {\n    // TODO: cors improve\n    // const xhr = new XMLHttpRequest()\n    // xhr.responseType = 'blob'\n    // xhr.open('GET', url, true)\n    // xhr.onload = function() {\n    //   const img = new Image()\n    //   img.onload = function() {\n    //     this.loadImageElement(img, callback)\n    //   }\n    //   img.onerror = (err: any) => {\n    //     console.log(err)\n    //   }\n    //   console.log(this.response)\n\n    //   img.src = URL.createObjectURL(this.response)\n    // }\n    // xhr.onerror = (err: any) => console.log(err)\n    // xhr.send(null)\n    const load = (\n      resolve: (imgd: ImageData) => void,\n      reject?: (a: any) => void\n    ) => {\n      const img = new Image()\n      if (this.corsenabled) {\n        img.crossOrigin = 'Anonymous'\n      }\n      img.onload = () => {\n        this.fromImageElement(img, resolve)\n      }\n      img.onerror = (err: any) => {\n        if (reject) {\n          reject(err)\n        } else {\n          console.error(err)\n        }\n      }\n      img.src = url\n    }\n    if (callback) {\n      load(callback)\n    } else {\n      return new Promise(load)\n    }\n  }\n\n  // TODO: improve types.\n  // if exists callback, return void. if not existed callback, return Promise<ImageData>.\n  public fromImageElement(\n    img: HTMLImageElement,\n    callback?: (imgd: ImageData) => void\n  ): Promise<ImageData> | void {\n    const load = (\n      resolve: (imgd: ImageData) => void,\n      reject?: (a: any) => void\n    ) => {\n      const canvas = document.createElement('canvas')\n      canvas.width = img.naturalWidth || img.width\n      canvas.height = img.naturalHeight || img.height\n      const context = canvas.getContext('2d')\n      context?.drawImage(img, 0, 0)\n      const imgd: ImageData | undefined = context?.getImageData(\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      )\n      if (!imgd) {\n        if (reject) {\n          reject('error canvas context.')\n          return\n        } else {\n          throw 'error canvas context.'\n        }\n      }\n      resolve(imgd)\n    }\n    if (callback) {\n      load(callback)\n    } else {\n      return new Promise(load)\n    }\n  }\n}\n","import { convertRGBAImage } from './utils/convertRGBAImage'\n\nexport interface Rgba {\n  r: number\n  g: number\n  b: number\n  a: number\n}\n\nconst DEFAULT_NUMBER_OF_COLORS = 16\nexport interface FromImageDataOptions {\n  numberOfColors?: number\n  colorQuantCycles?: number\n}\nexport class Palette {\n  // Deterministic sampling a palette from imagedata: rectangular grid\n  public static imageData(\n    argimgd: ImageData,\n    { numberOfColors, colorQuantCycles }: FromImageDataOptions = {}\n  ): Rgba[] {\n    const nc = numberOfColors || DEFAULT_NUMBER_OF_COLORS\n    const cqc = colorQuantCycles || 3\n    const imgd = convertRGBAImage(argimgd)\n\n    const palette = this._deterministic(imgd, nc)\n    let paletteacc: {\n      r: number\n      g: number\n      b: number\n      a: number\n      n: number\n    }[] = []\n    // Using a form of k-means clustering repeatead options.colorquantcycles times. http://en.wikipedia.org/wiki/Color_quantization\n    for (let cnt = 0; cnt < cqc; cnt++) {\n      if (cnt > 0) {\n        for (let k = 0; k < palette.length; k++) {\n          // averaging\n          if (paletteacc[k].n > 0) {\n            palette[k] = {\n              r: Math.floor(paletteacc[k].r / paletteacc[k].n),\n              g: Math.floor(paletteacc[k].g / paletteacc[k].n),\n              b: Math.floor(paletteacc[k].b / paletteacc[k].n),\n              a: Math.floor(paletteacc[k].a / paletteacc[k].n),\n            }\n          }\n        }\n      }\n\n      paletteacc = Array.from({ length: palette.length }, () => ({\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n        n: 0,\n      }))\n\n      // loop through all pixels\n      for (let j = 0; j < imgd.height; j++) {\n        for (let i = 0; i < imgd.width; i++) {\n          // pixel index\n          const idx = (j * imgd.width + i) * 4\n\n          // find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors\n          // In my experience, https://en.wikipedia.org/wiki/Rectilinear_distance works better than https://en.wikipedia.org/wiki/Euclidean_distance\n          let cdl = 1024 // 4 * 256 is the maximum RGBA distance\n          const ci = palette.reduce((findId: number, pal: Rgba, id: number) => {\n            const cd =\n              Math.abs(pal.r - imgd.data[idx]) +\n              Math.abs(pal.g - imgd.data[idx + 1]) +\n              Math.abs(pal.b - imgd.data[idx + 2]) +\n              Math.abs(pal.a - imgd.data[idx + 3])\n            if (cd < cdl) {\n              cdl = cd\n              return id\n            }\n            return findId\n          }, 0)\n\n          // add to palettacc\n          paletteacc[ci].r += imgd.data[idx]\n          paletteacc[ci].g += imgd.data[idx + 1]\n          paletteacc[ci].b += imgd.data[idx + 2]\n          paletteacc[ci].a += imgd.data[idx + 3]\n          paletteacc[ci].n += 1\n        }\n      }\n    }\n    return palette\n  }\n\n  // Deterministic sampling a palette from imagedata: rectangular grid\n  private static _deterministic(\n    imgd: ImageData,\n    numberOfColors: number\n  ): Rgba[] {\n    const palette: Rgba[] = []\n    const ni = Math.ceil(Math.sqrt(numberOfColors))\n    const nj = Math.ceil(numberOfColors / ni)\n    const vx = imgd.width / (ni + 1)\n    const vy = imgd.height / (nj + 1)\n    for (let j = 0; j < nj; j++) {\n      for (let i = 0; i < ni; i++) {\n        if (palette.length === numberOfColors) break\n        const idx = Math.floor((j + 1) * vy * imgd.width + (i + 1) * vx) * 4\n        palette.push({\n          r: imgd.data[idx],\n          g: imgd.data[idx + 1],\n          b: imgd.data[idx + 2],\n          a: imgd.data[idx + 3],\n        })\n      }\n    }\n    return palette\n  }\n  // Generating a palette with number of colors\n  public static number(\n    numberofcolors: number = DEFAULT_NUMBER_OF_COLORS\n  ): Rgba[] {\n    if (numberofcolors < 8) return this.grey(numberofcolors)\n    const palette: Rgba[] = []\n    const colorqnum = Math.floor(Math.pow(numberofcolors, 1 / 3))\n    const colorstep = Math.floor(255 / (colorqnum - 1))\n\n    for (let r = 0; r < colorqnum; r += 1) {\n      for (let g = 0; g < colorqnum; g += 1) {\n        for (let b = 0; b < colorqnum; b += 1) {\n          palette.push({\n            r: r * colorstep,\n            g: g * colorstep,\n            b: b * colorstep,\n            a: 255,\n          })\n        }\n      }\n    }\n\n    // TODO: rest improve\n    // TODO: test\n    const rest = numberofcolors - colorqnum * colorqnum * colorqnum\n    for (let rcnt = 0; rcnt < rest; rcnt++) {\n      palette.push({\n        r: Math.floor(Math.random() * 255),\n        g: Math.floor(Math.random() * 255),\n        b: Math.floor(Math.random() * 255),\n        a: Math.floor(Math.random() * 255),\n      })\n    }\n\n    return palette\n  }\n\n  public static grey(\n    numberofcolors: number = DEFAULT_NUMBER_OF_COLORS\n  ): Rgba[] {\n    const palette: Rgba[] = []\n    const graystep = Math.floor(255 / (numberofcolors - 1))\n    for (let i = 0; i < numberofcolors; i++) {\n      palette.push({\n        r: i * graystep,\n        g: i * graystep,\n        b: i * graystep,\n        a: 255,\n      })\n    }\n\n    return palette\n  }\n}\n","import {\n  Svg,\n  Path,\n  Move,\n  Close,\n  Point,\n  Line,\n  QuadraticCurve,\n} from '@svg-drawing/core'\nimport { convertRGBAImage } from './utils/convertRGBAImage'\nimport type { Rgba } from './palette'\nimport type { CommandClass, PathClass, PathAttributes } from '@svg-drawing/core'\n\ntype ColorQuantization = number[][]\n// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n// 12    ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n// 48    ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n// Type  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\ntype EdgeType =\n  | -1 // Empty\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\ntype EdgeLayer = EdgeType[][]\n\ninterface PathInfo {\n  commands: CommandClass[]\n  holeCommands: CommandClass[]\n  holechildren: number[]\n  isholepath: boolean\n}\ninterface PointInfo {\n  points: DirectionPoint[]\n  boundingbox: [number, number, number, number]\n  holechildren: number[]\n  isholepath: boolean\n}\n\ntype DirectionValue = typeof DIRECTION_TYPE[keyof typeof DIRECTION_TYPE]\nconst DIRECTION_TYPE = {\n  RIGHT: 0,\n  RIGHT_BOTTOM: 1,\n  BOTTOM: 2,\n  LEFT_BOTTOM: 3,\n  LEFT: 4,\n  LEFT_TOP: 5,\n  TOP: 6,\n  RIGHT_TOP: 7,\n  CENTER: 8,\n  EMPTY: -1,\n} as const\ninterface DirectionPoint {\n  x: number\n  y: number\n  direction: DirectionValue\n}\n\nexport interface ImgTraceOption {\n  // Tracing\n  ltres?: number\n  qtres?: number\n  rightangleenhance?: boolean\n  // filter\n  pathOmit?: number\n  commandOmit?: number\n  // override path element attribute\n  pathAttrs?: PathAttributes\n  palettes?: Rgba[]\n}\n\nconst pathscanCombinedLookup: EdgeType[][][] = [\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ], // arr[py][px]===0 is invalid\n  [\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [0, 0, 1, 0],\n  ],\n  [\n    [0, 0, 1, 0],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [-1, -1, -1, -1],\n    [0, 0, 1, 0],\n    [0, 3, 0, 1],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [13, 3, 0, 1],\n    [13, 2, -1, 0],\n    [7, 1, 0, -1],\n    [7, 0, 1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [0, 3, 0, 1],\n  ],\n  [\n    [0, 3, 0, 1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [0, 3, 0, 1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [0, 3, 0, 1],\n  ],\n  [\n    [11, 1, 0, -1],\n    [14, 0, 1, 0],\n    [14, 3, 0, 1],\n    [11, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [0, 0, 1, 0],\n    [0, 3, 0, 1],\n    [-1, -1, -1, -1],\n  ],\n\n  [\n    [0, 0, 1, 0],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n    [-1, -1, -1, -1],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 1, 0, -1],\n    [0, 0, 1, 0],\n  ],\n  [\n    [0, 1, 0, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [0, 2, -1, 0],\n  ],\n  [\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n    [-1, -1, -1, -1],\n  ], // arr[py][px]===15 is invalid\n]\n\nconst DEFAULT_PALETTES = [\n  { r: 0, g: 0, b: 0, a: 255 },\n  { r: 50, g: 50, b: 50, a: 255 },\n  { r: 100, g: 100, b: 100, a: 255 },\n  { r: 150, g: 150, b: 150, a: 255 },\n  { r: 200, g: 200, b: 200, a: 255 },\n]\n\nexport class ImgTrace {\n  // Tracing\n  public ltres: number\n  public qtres: number\n  public rightangleenhance: boolean\n  // Filter\n  public pathOmit: number\n  public commandOmit: number\n  // Path element attribute\n  public pathAttrs: PathAttributes\n  // Palettes\n  public palettes: Rgba[]\n\n  // creating options object, setting defaults for missing values\n  constructor(opts: ImgTraceOption = {}) {\n    // Tracing\n    this.ltres = opts.ltres ?? 1\n    this.qtres = opts.qtres ?? 1\n    this.rightangleenhance = opts.rightangleenhance ?? true\n\n    // Filter\n    this.pathOmit = opts.pathOmit ?? 8\n    this.commandOmit = opts.commandOmit ?? 0\n\n    // SVG rendering\n    this.pathAttrs = { strokeWidth: '1', ...(opts.pathAttrs || {}) }\n\n    // Palette\n    this.palettes = opts.palettes || DEFAULT_PALETTES\n  }\n\n  public load(argImgd: ImageData): Svg {\n    const imgd = convertRGBAImage(argImgd)\n    const cq = this._colorQuantization(imgd)\n    const pathLayer: PathInfo[][] = []\n    for (let paletteId = 0; paletteId < this.palettes.length; paletteId++) {\n      const edge = this._edgeDetection(cq, paletteId)\n      const path = this._pathScan(edge)\n      const interporation = this._interpolation(path)\n      const tracedpath = interporation.map(this._tracePath.bind(this))\n      pathLayer.push(tracedpath)\n    }\n    const paths = this._createPaths(pathLayer)\n    return new Svg({\n      width: cq[0].length - 2,\n      height: cq.length - 2,\n    }).addPath(paths)\n  }\n\n  private _colorQuantization(imgd: ImageData): ColorQuantization {\n    return Array.from({ length: imgd.height + 2 }, (_h, j) =>\n      Array.from({ length: imgd.width + 2 }, (_w, i) => {\n        if (\n          i === 0 ||\n          i === imgd.width + 1 ||\n          j === 0 ||\n          j === imgd.height + 1\n        ) {\n          return -1\n        }\n        // pixel index\n        const h = j - 1\n        const w = i - 1\n        const idx = (h * imgd.width + w) * 4\n        return this._findPaletteIndex({\n          r: imgd.data[idx],\n          g: imgd.data[idx + 1],\n          b: imgd.data[idx + 2],\n          a: imgd.data[idx + 3],\n        })\n      })\n    )\n  }\n\n  /**\n   * Find similar color from palette and return ID\n   *\n   * @param {Rgba} color Pixel color\n   */\n  private _findPaletteIndex({ r, g, b, a }: Rgba): number {\n    let cdl = 1024 // 4 * 256 is the maximum RGBA distance\n    return this.palettes.reduce((findId, pal, id) => {\n      const cd =\n        Math.abs(pal.r - r) +\n        Math.abs(pal.g - g) +\n        Math.abs(pal.b - b) +\n        Math.abs(pal.a - a)\n      if (cd < cdl) {\n        cdl = cd\n        return id\n      }\n      return findId\n    }, 0)\n  }\n\n  private _edgeDetection(cq: ColorQuantization, palId: number): EdgeLayer {\n    const res: EdgeLayer = []\n    const ah = cq.length\n    const aw = cq[0].length\n\n    for (let h = 0; h < ah; h++) {\n      res[h] = []\n      for (let w = 0; w < aw; w++) {\n        res[h][w] =\n          h === 0 || w === 0\n            ? 0\n            : (((cq[h - 1][w - 1] === palId ? 1 : 0) +\n                (cq[h - 1][w] === palId ? 2 : 0) +\n                (cq[h][w - 1] === palId ? 8 : 0) +\n                (cq[h][w] === palId ? 4 : 0)) as EdgeType)\n      }\n    }\n\n    return res\n  }\n\n  private _pointpoly(p: DirectionPoint, pa: DirectionPoint[]): boolean {\n    let isin = false\n\n    for (let i = 0, j = pa.length - 1; i < pa.length; j = i++) {\n      isin =\n        pa[i].y > p.y !== pa[j].y > p.y &&\n        p.x <\n          ((pa[j].x - pa[i].x) * (p.y - pa[i].y)) / (pa[j].y - pa[i].y) +\n            pa[i].x\n          ? !isin\n          : isin\n    }\n\n    return isin\n  }\n\n  private _pathScan(edge: EdgeLayer): PointInfo[] {\n    const width = edge[0].length\n    const height = edge.length\n    const paths: PointInfo[] = []\n    let pacnt = 0\n\n    for (let h = 0; h < height; h++) {\n      for (let w = 0; w < width; w++) {\n        // Related for edgeDetection methods\n        const edgeType = edge[h][w]\n        if (edgeType !== 4 && edgeType !== 11) {\n          continue\n        }\n        let px = w\n        let py = h\n        let dir = 1\n        let pcnt = 0\n        let pathfinished = false\n        paths[pacnt] = {\n          points: [],\n          boundingbox: [px, py, px, py],\n          holechildren: [],\n          isholepath: false,\n        }\n\n        while (!pathfinished) {\n          paths[pacnt].points[pcnt] = {\n            x: px - 1,\n            y: py - 1,\n            direction: DIRECTION_TYPE.EMPTY,\n          }\n\n          if (px - 1 < paths[pacnt].boundingbox[0]) {\n            paths[pacnt].boundingbox[0] = px - 1\n          }\n          if (px - 1 > paths[pacnt].boundingbox[2]) {\n            paths[pacnt].boundingbox[2] = px - 1\n          }\n          if (py - 1 < paths[pacnt].boundingbox[1]) {\n            paths[pacnt].boundingbox[1] = py - 1\n          }\n          if (py - 1 > paths[pacnt].boundingbox[3]) {\n            paths[pacnt].boundingbox[3] = py - 1\n          }\n\n          const lookuprow = pathscanCombinedLookup[edge[py][px]][dir]\n          edge[py][px] = lookuprow[0]\n          dir = lookuprow[1]\n          px += lookuprow[2]\n          py += lookuprow[3]\n\n          // Close path\n          if (\n            px - 1 === paths[pacnt].points[0].x &&\n            py - 1 === paths[pacnt].points[0].y\n          ) {\n            pathfinished = true\n\n            if (paths[pacnt].points.length < this.pathOmit) {\n              paths.pop()\n            } else {\n              if (edgeType === 11) {\n                paths[pacnt].isholepath = true\n                let parentidx = 0\n                let parentbbox = [-1, -1, width + 1, height + 1]\n                for (let parentcnt = 0; parentcnt < pacnt; parentcnt++) {\n                  if (\n                    !paths[parentcnt].isholepath &&\n                    this._boundingboxincludes(\n                      paths[parentcnt].boundingbox,\n                      paths[pacnt].boundingbox\n                    ) &&\n                    this._boundingboxincludes(\n                      parentbbox,\n                      paths[parentcnt].boundingbox\n                    ) &&\n                    this._pointpoly(\n                      paths[pacnt].points[0],\n                      paths[parentcnt].points\n                    )\n                  ) {\n                    parentidx = parentcnt\n                    parentbbox = paths[parentcnt].boundingbox\n                  }\n                }\n                paths[parentidx].holechildren.push(pacnt)\n              }\n              pacnt++\n            }\n          }\n          pcnt++\n        }\n      }\n    }\n\n    return paths\n  }\n\n  private _boundingboxincludes(\n    parentbbox: number[],\n    childbbox: number[]\n  ): boolean {\n    return (\n      parentbbox[0] < childbbox[0] &&\n      parentbbox[1] < childbbox[1] &&\n      parentbbox[2] > childbbox[2] &&\n      parentbbox[3] > childbbox[3]\n    )\n  }\n  private _interpolation(paths: PointInfo[]): PointInfo[] {\n    const ins: PointInfo[] = []\n    let nextidx = 0\n    let nextidx2 = 0\n    let previdx = 0\n    let previdx2 = 0\n\n    for (let pacnt = 0; pacnt < paths.length; pacnt++) {\n      ins[pacnt] = {\n        points: [],\n        boundingbox: paths[pacnt].boundingbox,\n        holechildren: paths[pacnt].holechildren,\n        isholepath: paths[pacnt].isholepath,\n      }\n      const palen = paths[pacnt].points.length\n\n      for (let pcnt = 0; pcnt < palen; pcnt++) {\n        nextidx = (pcnt + 1) % palen\n        nextidx2 = (pcnt + 2) % palen\n        previdx = (pcnt - 1 + palen) % palen\n        previdx2 = (pcnt - 2 + palen) % palen\n\n        if (\n          this.rightangleenhance &&\n          this._testrightangle(\n            paths[pacnt],\n            previdx2,\n            previdx,\n            pcnt,\n            nextidx,\n            nextidx2\n          )\n        ) {\n          if (ins[pacnt].points.length > 0) {\n            ins[pacnt].points[ins[pacnt].points.length - 1].direction =\n              this._getdirection(\n                ins[pacnt].points[ins[pacnt].points.length - 1].x,\n                ins[pacnt].points[ins[pacnt].points.length - 1].y,\n                paths[pacnt].points[pcnt].x,\n                paths[pacnt].points[pcnt].y\n              )\n          }\n\n          ins[pacnt].points.push({\n            x: paths[pacnt].points[pcnt].x,\n            y: paths[pacnt].points[pcnt].y,\n            direction: this._getdirection(\n              paths[pacnt].points[pcnt].x,\n              paths[pacnt].points[pcnt].y,\n              (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) /\n                2,\n              (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2\n            ),\n          })\n        }\n\n        ins[pacnt].points.push({\n          x: (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2,\n          y: (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2,\n          direction: this._getdirection(\n            paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x,\n            paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y,\n            paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x,\n            paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y\n          ),\n        })\n      }\n    }\n\n    return ins\n  }\n\n  private _testrightangle(\n    path: PointInfo,\n    idx1: number,\n    idx2: number,\n    idx3: number,\n    idx4: number,\n    idx5: number\n  ): boolean {\n    return (\n      (path.points[idx3].x === path.points[idx1].x &&\n        path.points[idx3].x === path.points[idx2].x &&\n        path.points[idx3].y === path.points[idx4].y &&\n        path.points[idx3].y === path.points[idx5].y) ||\n      (path.points[idx3].y === path.points[idx1].y &&\n        path.points[idx3].y === path.points[idx2].y &&\n        path.points[idx3].x === path.points[idx4].x &&\n        path.points[idx3].x === path.points[idx5].x)\n    )\n  }\n\n  private _getdirection(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number\n  ): DirectionValue {\n    if (x1 < x2) {\n      if (y1 < y2) {\n        return DIRECTION_TYPE.RIGHT_BOTTOM\n      }\n      if (y1 > y2) {\n        return DIRECTION_TYPE.RIGHT_TOP\n      }\n      return DIRECTION_TYPE.RIGHT_TOP\n    }\n    if (x1 > x2) {\n      if (y1 < y2) {\n        return DIRECTION_TYPE.LEFT_BOTTOM\n      }\n      if (y1 > y2) {\n        return DIRECTION_TYPE.LEFT_TOP\n      }\n      return DIRECTION_TYPE.LEFT\n    }\n\n    if (y1 < y2) {\n      return DIRECTION_TYPE.BOTTOM\n    }\n    if (y1 > y2) {\n      return DIRECTION_TYPE.TOP\n    }\n    return DIRECTION_TYPE.CENTER\n  }\n\n  private _tracePath(path: PointInfo): PathInfo {\n    let pcnt = 0\n    const comms: CommandClass[] = []\n    const holes: CommandClass[] = []\n    while (pcnt < path.points.length) {\n      // 5.1. Find sequences of points with only 2 segment types\n      const segtype1: DirectionValue = path.points[pcnt].direction\n      let segtype2: DirectionValue = DIRECTION_TYPE.EMPTY\n      let seqend = pcnt + 1\n      while (\n        (path.points[seqend].direction === segtype1 ||\n          path.points[seqend].direction === segtype2 ||\n          segtype2 === -1) &&\n        seqend < path.points.length - 1\n      ) {\n        if (\n          path.points[seqend].direction !== segtype1 &&\n          segtype2 === DIRECTION_TYPE.EMPTY\n        ) {\n          segtype2 = path.points[seqend].direction || DIRECTION_TYPE.RIGHT\n        }\n        seqend++\n      }\n\n      if (seqend === path.points.length - 1) {\n        comms.push(...this._fitseq(path, pcnt, 0))\n        holes.push(...this._fitseq(path, pcnt, 0, true))\n        pcnt = path.points.length\n      } else {\n        comms.push(...this._fitseq(path, pcnt, seqend))\n        holes.push(...this._fitseq(path, pcnt, seqend, true))\n        pcnt = seqend\n      }\n    }\n\n    const commands = [\n      new Move(new Point(path.points[0].x, path.points[0].y)),\n      ...comms,\n      new Close(),\n    ]\n    holes.reverse()\n    const value = holes[holes.length - 1].values.slice(0, 2)\n    const holeCommands = [\n      new Move(new Point(value[0], value[1])),\n      ...holes,\n      new Close(),\n    ]\n    return {\n      commands,\n      holeCommands,\n      holechildren: path.holechildren,\n      isholepath: path.isholepath,\n    }\n  }\n\n  private _fitseq(\n    path: PointInfo,\n    seqstart: number,\n    seqend: number,\n    isHolePath?: boolean\n  ): CommandClass[] {\n    const ltres = this.ltres\n    const qtres = this.qtres\n    if (seqend > path.points.length || seqend < 0) {\n      return []\n    }\n    let errorpoint = seqstart\n    let errorval = 0\n    let curvepass = true\n    let px\n    let py\n    let dist2\n    let tl = seqend - seqstart\n    if (tl < 0) {\n      tl += path.points.length\n    }\n    const vx = (path.points[seqend].x - path.points[seqstart].x) / tl\n    const vy = (path.points[seqend].y - path.points[seqstart].y) / tl\n\n    let pcnt = (seqstart + 1) % path.points.length\n    while (pcnt != seqend) {\n      let pl = pcnt - seqstart\n      if (pl < 0) {\n        pl += path.points.length\n      }\n      px = path.points[seqstart].x + vx * pl\n      py = path.points[seqstart].y + vy * pl\n      dist2 =\n        (path.points[pcnt].x - px) * (path.points[pcnt].x - px) +\n        (path.points[pcnt].y - py) * (path.points[pcnt].y - py)\n      if (dist2 > ltres) {\n        curvepass = false\n      }\n      if (dist2 > errorval) {\n        errorpoint = pcnt\n        errorval = dist2\n      }\n      pcnt = (pcnt + 1) % path.points.length\n    }\n\n    if (curvepass) {\n      return [\n        new Line(\n          isHolePath\n            ? new Point(path.points[seqstart].x, path.points[seqstart].y)\n            : new Point(path.points[seqend].x, path.points[seqend].y)\n        ),\n      ]\n    }\n\n    const fitpoint = errorpoint\n    curvepass = true\n    errorval = 0\n\n    let t = (fitpoint - seqstart) / tl\n    let t1 = (1 - t) * (1 - t)\n    let t2 = 2 * (1 - t) * t\n    let t3 = t * t\n    const cpx =\n      (t1 * path.points[seqstart].x +\n        t3 * path.points[seqend].x -\n        path.points[fitpoint].x) /\n      -t2\n    const cpy =\n      (t1 * path.points[seqstart].y +\n        t3 * path.points[seqend].y -\n        path.points[fitpoint].y) /\n      -t2\n\n    pcnt = seqstart + 1\n    while (pcnt != seqend) {\n      t = (pcnt - seqstart) / tl\n      t1 = (1 - t) * (1 - t)\n      t2 = 2 * (1 - t) * t\n      t3 = t * t\n      px = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x\n      py = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y\n\n      dist2 =\n        (path.points[pcnt].x - px) * (path.points[pcnt].x - px) +\n        (path.points[pcnt].y - py) * (path.points[pcnt].y - py)\n\n      if (dist2 > qtres) {\n        curvepass = false\n      }\n      if (dist2 > errorval) {\n        errorpoint = pcnt\n        errorval = dist2\n      }\n      pcnt = (pcnt + 1) % path.points.length\n    }\n    if (curvepass) {\n      return [\n        new QuadraticCurve([\n          new Point(cpx, cpy),\n          new Point(path.points[seqend].x, path.points[seqend].y),\n        ]),\n      ]\n    }\n    const splitpoint = fitpoint\n\n    return this._fitseq(path, seqstart, splitpoint, isHolePath).concat(\n      this._fitseq(path, splitpoint, seqend, isHolePath)\n    )\n  }\n\n  private _complementCommand(\n    info: PathInfo[],\n    layerIndex: number\n  ): CommandClass[] {\n    const p = info[layerIndex]\n    const complement = []\n    for (let hcnt = 0; hcnt < p.holechildren.length; hcnt++) {\n      complement.push(...info[p.holechildren[hcnt]].holeCommands)\n    }\n    return complement\n  }\n\n  private _createPaths(pathLayer: PathInfo[][]): PathClass[] {\n    const result: PathClass[] = []\n    for (let lcnt = 0; lcnt < pathLayer.length; lcnt++) {\n      for (let pcnt = 0; pcnt < pathLayer[lcnt].length; pcnt++) {\n        const layer = pathLayer[lcnt]\n        const smp = layer[pcnt]\n        if (smp.isholepath || smp.commands.length < this.commandOmit) continue\n        const rgba = this.palettes[lcnt]\n        const color = `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`\n        const path = new Path({\n          ...this.pathAttrs,\n          stroke: color,\n          fill: color,\n          opacity: String(rgba.a / 255.0),\n        })\n        path.addCommand([\n          ...smp.commands,\n          ...this._complementCommand(layer, pcnt),\n        ])\n        result.push(path)\n      }\n    }\n\n    return result\n  }\n}\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","this","convertRGBAImage","imgd","pixelnum","width","height","data","rgbaImgd","Uint8ClampedArray","pxcnt","gks","Blur","_ref","radius","delta","argimgd","Math","floor","abs","thisgk","j","racc","gacc","bacc","aacc","wacc","k","idx","himgd","ImageData","ImgLoader","options","_options$corsenabled","corsenabled","_proto","fromUrl","url","callback","_this","load","resolve","reject","img","Image","crossOrigin","onload","fromImageElement","onerror","err","console","error","src","Promise","canvas","document","createElement","naturalWidth","naturalHeight","context","getContext","drawImage","getImageData","Palette","imageData","_temp","nc","numberOfColors","cqc","colorQuantCycles","palette","_deterministic","paletteacc","cnt","n","r","g","b","a","Array","from","_loop","cdl","ci","reduce","findId","pal","id","cd","ni","ceil","sqrt","nj","vx","vy","push","number","numberofcolors","grey","colorqnum","pow","colorstep","rest","rcnt","random","graystep","DIRECTION_TYPE","pathscanCombinedLookup","DEFAULT_PALETTES","ImgTrace","opts","_opts$ltres","_opts$qtres","_opts$rightangleenhan","_opts$pathOmit","_opts$commandOmit","ltres","qtres","rightangleenhance","pathOmit","commandOmit","pathAttrs","strokeWidth","palettes","argImgd","cq","_colorQuantization","pathLayer","paletteId","edge","_edgeDetection","path","_pathScan","tracedpath","_interpolation","map","_tracePath","bind","paths","_createPaths","Svg","addPath","_h","_w","w","_findPaletteIndex","palId","res","ah","aw","h","_pointpoly","p","pa","isin","y","x","pacnt","edgeType","px","py","dir","pcnt","pathfinished","points","boundingbox","holechildren","isholepath","direction","lookuprow","pop","parentidx","parentbbox","parentcnt","_boundingboxincludes","childbbox","ins","nextidx","nextidx2","previdx","previdx2","palen","_testrightangle","_getdirection","idx1","idx2","idx3","idx4","idx5","x1","y1","x2","y2","comms","holes","segtype1","segtype2","seqend","_fitseq","commands","Move","Point","concat","Close","reverse","values","slice","holeCommands","seqstart","isHolePath","dist2","errorpoint","errorval","curvepass","tl","pl","Line","fitpoint","t","t1","t2","t3","cpx","cpy","QuadraticCurve","splitpoint","_complementCommand","info","layerIndex","complement","hcnt","result","lcnt","layer","smp","rgba","color","Path","stroke","fill","opacity","String","addCommand"],"mappings":"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"}