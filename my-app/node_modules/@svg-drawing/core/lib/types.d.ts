/** Point Object */
export declare type PointObject = Readonly<{
    x: number;
    y: number;
}>;
export interface PointClass {
    readonly x: number;
    readonly y: number;
    scale: (r: number) => PointClass;
    scaleX: (r: number) => PointClass;
    scaleY: (r: number) => PointClass;
    add: (p: PointObject) => PointClass;
    sub: (p: PointObject) => PointClass;
    clone: () => PointClass;
    toJson: () => PointObject;
}
export declare type VectorObject = Readonly<{
    value: number;
    angle: number;
}>;
export interface VectorClass {
    readonly value: number;
    readonly angle: number;
    scale: (r: number) => VectorClass;
    rotate: (a: number) => VectorClass;
    toJson: () => VectorObject;
}
/** Command Object */
export declare type RelativeCommandType = 'm' | 'l' | 'c' | 'q' | 's';
export declare type AbsoluteCommandType = Uppercase<RelativeCommandType>;
export declare type OtherCommandType = 'h' | 'v' | 'a' | 'H' | 'V' | 'A' | 'Z' | 'z';
export declare type CommandType = RelativeCommandType | AbsoluteCommandType | OtherCommandType;
declare type PointsLengthMap<T = CommandType> = T extends OtherCommandType ? PointClass[] : T extends 'm' | 'M' | 'l' | 'L' ? [PointClass] : T extends 'C' | 'c' ? [PointClass, PointClass, PointClass] : [PointClass, PointClass];
export declare type CommandObject = {
    type: CommandType;
    value: number[];
};
export interface CommandClass<T = CommandType> {
    type: T;
    values: number[];
    points: PointsLengthMap<T>;
    point: T extends OtherCommandType ? undefined : PointClass;
    toString: () => string;
    clone: () => CommandClass<T>;
    scale: (r: number) => CommandClass<T>;
    scaleX: (r: number) => CommandClass<T>;
    scaleY: (r: number) => CommandClass<T>;
    translate: (po: PointObject) => CommandClass<T>;
}
/** Object for SVGPathElement attributes. */
export declare type PathAttributes = {
    [camelCase: string]: string | undefined;
};
export declare type PathObject = {
    key: string;
    type: keyof SVGElementTagNameMap;
    attributes: PathAttributes;
};
export interface PathClass {
    /** Identification key. Use for update, delete. Return same key when PathClass cloned. */
    key: string;
    attrs: PathAttributes;
    /** Path data. */
    absoluteCommands: CommandClass[];
    relativeCommands: CommandClass[];
    scale: (r: number) => this;
    scaleX: (r: number) => this;
    scaleY: (r: number) => this;
    addCommand: (params: CommandClass | CommandClass[]) => this;
    updateCommand: (i: number, update: (absoluteCommand: CommandClass) => CommandClass) => this;
    updateCommands: (commands: CommandClass[]) => this;
    deleteCommand: (i: number) => this;
    translate: (p: PointObject) => this;
    setAttributes: (attr: PathAttributes) => this;
    updateAttributes: (attr: PathAttributes) => this;
    clone: () => PathClass;
    getCommandString: () => string;
    toJson: () => PathObject;
}
/** Svg JSON */
export declare type SvgObject = {
    width: number;
    height: number;
    background?: string;
    paths: PathObject[];
};
/** Svg options */
export declare type SvgOption = {
    width: number;
    height: number;
    background?: string;
};
export interface SvgClass {
    /** Path of children. */
    paths: PathClass[];
    width: number;
    height: number;
    background?: string;
    /** Resize svg and path of children. */
    resize: (arg: {
        width: number;
        height: number;
    }) => void;
    /** Add multiple paths. */
    addPath: (path: PathClass | PathClass[]) => this;
    /** Get path */
    getPath: (key: string) => PathClass | undefined;
    /** Update path */
    updatePath: (path: PathClass) => this;
    /** Delete paths */
    deletePath: (path: PathClass) => this;
    /** Return cloned paths. */
    clonePaths: () => PathClass[];
    toJson: () => SvgObject;
    /**
     * Copy resized paths.
     *
     * ```ts
     * class Svg implements SvgClass {}
     *
     * const drawSvg = new Svg()
     * const animateSvg = new Svg().copy(drawSvg)
     * ```
     */
    copy: (svg: SvgClass) => this;
    /** Return cloned class object. */
    clone: () => SvgClass;
}
export declare type EventPoint = {
    x: number;
    y: number;
    pressure?: number;
};
/** Convert options */
export interface ConvertOption {
    ratio?: number;
}
/** Renderer options */
export declare type RendererOption = Pick<SvgOption, 'background'>;
/** SvgDrawing options */
export declare type DrawingOption = RendererOption & {
    penColor?: string;
    penWidth?: number;
    curve?: boolean;
    close?: boolean;
    delay?: number;
    fill?: string;
};
/** Download options */
export declare type DownloadOption = {
    extension: 'svg' | 'png' | 'jpg';
    filename?: string;
};
export declare type ResizeCallback = (arg: {
    width: number;
    height: number;
}) => void;
export interface ResizeEventHandler {
    active: boolean;
    on: () => void;
    off: () => void;
    setElement: (el: HTMLElement) => void;
    setHandler: (callback: ResizeCallback) => void;
}
export declare type DrawListenerType = 'pointer' | 'touch' | 'mouse';
export declare type DrawEventName = Extract<keyof GlobalEventHandlersEventMap, 'pointerdown' | 'pointermove' | 'pointerleave' | 'pointercancel' | 'pointerup' | 'touchstart' | 'touchmove' | 'touchend' | 'touchcancel' | 'mousedown' | 'mousemove' | 'mouseleave' | 'mouseout' | 'mouseup'>;
export declare type ClearListener = () => void;
export interface DrawFactory {
    /** Generate draw path. */
    createPath: () => PathClass;
    /** Generate command from point */
    createCommand: CreateCommand;
}
export interface DrawingClass {
    start: () => void;
    dot: (po: EventPoint) => void;
    end: () => void;
}
export interface DrawEventHandler {
    /** Return active event listener status. */
    isActive: boolean;
    on: () => void;
    off: () => void;
    setDrawing: (drawing: DrawingClass) => void;
    setElement: (el: HTMLElement) => void;
}
export declare type SelectPathIndex = {
    path: PathObject['key'];
    command?: undefined;
    point?: undefined;
};
export declare type SelectCommandIndex = {
    path: PathObject['key'];
    command: number;
    point?: undefined;
};
export declare type SelectPointIndex = {
    path: PathObject['key'];
    command: number;
    point: number;
};
export declare type SelectIndex = SelectPathIndex | SelectCommandIndex | SelectPointIndex;
/** Control Point */
export declare type EditVertex = {
    points: {
        index: SelectPointIndex;
        selected: boolean;
        value: PointObject;
    }[];
    d: string;
};
/** BoundingBox */
export declare type BoundingBoxObject = {
    x: number;
    y: number;
    width: number;
    height: number;
    vertex: Record<FixedType, PointObject>;
    selected: boolean;
};
export declare type EditPathObject = {
    key: PathObject['key'];
    d: string;
    vertex: EditVertex[];
};
export declare type EditSvgObject = {
    paths: Record<PathObject['key'], EditPathObject>;
    boundingBox: BoundingBoxObject;
};
export declare type FixedType = 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';
export declare type ResizeBoundingBoxBase = {
    fixedType: FixedType;
    point: PointObject;
};
export declare type CreateCommand = (points: EventPoint[]) => CommandClass[];
export declare type AnimationOption = {
    ms: number;
};
export interface FrameAnimation {
    loops: number;
    animation: (origin: PathClass[], key: number) => PathClass[];
}
export declare type AnimateAttribute = {
    [key in 'attributeName' | 'repeatCount' | 'dur' | 'keyTimes' | 'values']: string;
};
export declare type AnimateObject = {
    type: 'animate';
    attributes: AnimateAttribute;
};
export declare type AnimationObject = Record<string, AnimateObject[]>;
export {};
